name: Test Real VLESS Reality Configs

on:
  workflow_run:
    workflows: ["auto-task.yml"] # Ø§ÛŒÙ†Ø¬Ø§ Ù†Ø§Ù… Ø¯Ù‚ÛŒÙ‚ Workflow Ø§ØµÙ„ÛŒ Ø´Ù…Ø§ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª!
    types:
      - completed
    branches:
      - main # ÛŒØ§ Ø´Ø§Ø®Ù‡ Ø§ØµÙ„ÛŒ Ø±ÛŒÙ¾Ø§Ø²ÛŒØªÙˆØ±ÛŒ Ø´Ù…Ø§ (Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ main Ø§Ø³Øª)

  workflow_dispatch: # Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¨ØªÙˆØ§Ù†ÛŒØ¯ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø³ØªÛŒ Ù‡Ù… Ø§Ø¬Ø±Ø§ Ú©Ù†ÛŒØ¯

jobs:
  test_configs_job:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Xray Core
        run: |
          # Fetch the latest Xray release tag
          XRAY_VERSION=$(curl -s "https://api.github.com/repos/XTLS/Xray-core/releases/latest" | grep -Po '"tag_name": "v\K[^"]*')
          echo "Latest Xray version: v${XRAY_VERSION}"

          # Download Xray Core for Linux 64-bit
          XRAY_URL="https://github.com/XTLS/Xray-core/releases/download/v${XRAY_VERSION}/Xray-linux-64.zip"
          echo "Downloading Xray from: ${XRAY_URL}"
          curl -L -o xray.zip $XRAY_URL

          # Unzip Xray core and essential data files
          unzip xray.zip xray geoip.dat geosite.dat # Xray.dat Ø­Ø°Ù Ø´Ø¯
          
          # Move xray binary to a PATH directory and make it executable
          sudo mv xray /usr/local/bin/
          sudo chmod +x /usr/local/bin/xray

          # Create Xray data directory and move data files
          sudo mkdir -p /usr/local/share/xray/
          sudo mv Xray.dat geoip.dat geosite.dat /usr/local/share/xray/

          echo "Xray installed successfully. Version:"
          xray version

      - name: Create Xray Tester Script (xray_tester.py)
        run: |
          cat << 'EOF' > xray_tester.py
          # -- coding: utf-8 --
          import base64
          import json
          import os
          import re
          import subprocess
          import sys
          import time
          import threading
          from typing import List, Dict, Union, Optional
          import concurrent.futures

          # --- Global Constants & Variables ---

          PRINT_LOCK = threading.Lock() 

          # Ù…Ø³ÛŒØ± ÙØ§ÛŒÙ„ ÙˆØ±ÙˆØ¯ÛŒ (ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Workflow Ù‚Ø¨Ù„ÛŒ)
          INPUT_CONFIGS_FILE = "data/khanevadeh_base64.txt"
          # Ù…Ø³ÛŒØ± ÙØ§ÛŒÙ„ Ø®Ø±ÙˆØ¬ÛŒ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„ ÙˆØ§Ù‚Ø¹ÛŒ
          OUTPUT_WORKING_CONFIGS_FILE = "data/khanevadeh_pardazesh_shodeh_base64.txt" # Ø§Ø³Ù… ÙØ§ÛŒÙ„ Ø§ÛŒÙ†Ø¬Ø§ ØªØºÛŒÛŒØ± Ú©Ø±Ø¯Ù‡ Ø§Ø³Øª

          # Ø­Ø¯Ø§Ú©Ø«Ø± ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒÙ… ØªØ³Øª ÙˆØ§Ù‚Ø¹ÛŒ Ú©Ù†ÛŒÙ… (Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø²Ù…Ø§Ù† GitHub Actions)
          MAX_CONFIGS_FOR_REAL_TEST = 100 # Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯: Ø¨Ø§ 100 Ø´Ø±ÙˆØ¹ Ú©Ù†ÛŒØ¯ØŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯

          # Ù¾ÙˆØ±Øª Ø¯Ø§Ø®Ù„ÛŒ Ú©Ù‡ Xray Ø±ÙˆÛŒ Ø¢Ù† Ù¾Ø±ÙˆÚ©Ø³ÛŒ SOCKS5 Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
          XRAY_LOCAL_SOCKS_PORT = 1080
          # Ù¾ÙˆØ±Øª Ø¯Ø§Ø®Ù„ÛŒ Ú©Ù‡ Xray Ø±ÙˆÛŒ Ø¢Ù† Ù¾Ø±ÙˆÚ©Ø³ÛŒ HTTP Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ (Ø¨Ø±Ø§ÛŒ curl)
          XRAY_LOCAL_HTTP_PORT = 1081

          # Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§
          XRAY_STARTUP_TIMEOUT = 10 # Ø«Ø§Ù†ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Xray
          TEST_URL_TIMEOUT = 10     # Ø«Ø§Ù†ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ curl Ú©Ø±Ø¯Ù† URL ØªØ³Øª

          # URL Ø¨Ø±Ø§ÛŒ ØªØ³Øª Ø§ØªØµØ§Ù„ ÙˆØ§Ù‚Ø¹ÛŒ (ØªÙˆØµÛŒÙ‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ ÛŒÚ© URL Ù…Ø¹ØªØ¨Ø± Ùˆ Ø¹Ù…ÙˆÙ…ÛŒ Ø¨Ø§Ø´Ø¯ Ú©Ù‡ Ø¯Ø± Ø§ÛŒØ±Ø§Ù† ÙÛŒÙ„ØªØ± Ù†ÛŒØ³Øª Ùˆ Ø§Ø² CDN Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯)
          TEST_URL = "https://www.google.com/generate_204" # Ø§ÛŒÙ† URL ÙÙ‚Ø· ÛŒÚ© Ù¾Ø§Ø³Ø® 204 Ø¨Ø¯ÙˆÙ† Ù…Ø­ØªÙˆØ§ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ùˆ Ø³Ø±ÛŒØ¹ Ø§Ø³Øª.

          VLESS_PARSE_PATTERN: re.Pattern = re.compile(
              r"vless://"
              r"(?P<uuid>[a-f0-9-]+)"     
              r"@"
              r"(?P<server>[^:]+)"       
              r":"
              r"(?P<port>\d+)"           
              r"\?"                      
              r"(?:[^&]*&)*"             
              r"security=reality"        
              r"(?:[^&]*&)*"             
              r"pbk=(?P<pbk>[^&]+)"      
              r"(?:[^&]*&)*"             
              r"(?:fp=(?P<fp>[^&]+))?"   
              r"(?:&sni=(?P<sni>[^&]+))?" # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† sni Ø¨Ù‡ Ù¾ØªØ±Ù†
              r"(?:&alpn=(?P<alpn>[^&]+))?" # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† alpn Ø¨Ù‡ Ù¾ØªØ±Ù†
              r".*$",                    
              re.IGNORECASE
          )

          def safe_print(message: str) -> None:
              with PRINT_LOCK:
                  print(message)

          def print_progress(iteration: int, total: int, prefix: str = '', suffix: str = '', bar_length: int = 50) -> None:
              with PRINT_LOCK:
                  percent = ("{0:.1f}").format(100 * (iteration / float(total)))
                  filled_length = int(bar_length * iteration // total)
                  bar = 'â–ˆ' * filled_length + '-' * (bar_length - filled_length)
                  sys.stdout.write(f'\r{prefix} |{bar}| {percent}% {suffix}')
                  sys.stdout.flush()
                  if iteration == total:
                      sys.stdout.write('\n')

          def parse_vless_config(config_str: str) -> Optional[Dict[str, Union[str, int, str]]]:
              match = VLESS_PARSE_PATTERN.match(config_str)
              if match:
                  parts = match.groupdict()
                  if all(parts.get(k) for k in ["uuid", "server", "port", "pbk"]):
                      try:
                          port_int = int(parts["port"])
                          return {
                              "uuid": parts["uuid"],
                              "server": parts["server"],
                              "port": port_int,
                              "pbk": parts["pbk"],
                              "fp": parts.get("fp", ""),
                              "sni": parts.get("sni", ""),
                              "alpn": parts.get("alpn", "h2,http/1.1"), # Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ h2,http/1.1
                              "original_config": config_str
                          }
                      except ValueError:
                          return None
              return None

          def create_xray_config_file(config_data: Dict[str, Union[str, int, str]], config_path: str) -> bool:
              """Creates a temporary Xray config file for a given VLESS Reality configuration."""
              config_json = {
                  "log": {
                      "loglevel": "warning"
                  },
                  "inbounds": [
                      {
                          "port": XRAY_LOCAL_SOCKS_PORT,
                          "protocol": "socks",
                          "settings": {
                              "auth": "noauth",
                              "udp": True,
                              "ip": "127.0.0.1"
                          }
                      },
                      {
                          "port": XRAY_LOCAL_HTTP_PORT,
                          "protocol": "http",
                          "settings": {
                              "ip": "127.0.0.1"
                          }
                      }
                  ],
                  "outbounds": [
                      {
                          "protocol": "vless",
                          "settings": {
                              "vnext": [
                                  {
                                      "address": config_data["server"],
                                      "port": config_data["port"],
                                      "users": [
                                          {
                                              "id": config_data["uuid"],
                                              "encryption": "none"
                                          }
                                      ]
                                  }
                              ]
                          },
                          "streamSettings": {
                              "network": "tcp",
                              "security": "reality",
                              "realitySettings": {
                                  "publicKey": config_data["pbk"],
                                  "shortId": "", # Ù…Ø¹Ù…ÙˆÙ„Ø§ Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆØ±Ù‡Ø§ÛŒ Ø±Ø§ÛŒÚ¯Ø§Ù† Ø®Ø§Ù„ÛŒ Ø§Ø³Øª
                                  "fingerprint": config_data["fp"] if config_data["fp"] else "chrome", # Ø§Ø² fp Ú©Ø§Ù†ÙÛŒÚ¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù† ÛŒØ§ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ chrome
                                  "serverNames": [config_data["sni"]] if config_data["sni"] else ["www.google.com"], # Ø§Ø² sni Ú©Ø§Ù†ÙÛŒÚ¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù† ÛŒØ§ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ google.com
                                  "spiderX": ""
                              },
                              "tlsSettings": { # Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¨Ø±Ø§ÛŒ Reality Ø¶Ø±ÙˆØ±ÛŒ Ù†ÛŒØ³Øª Ø§Ù…Ø§ Ø¶Ø±Ø±ÛŒ Ù†Ø¯Ø§Ø±Ø¯
                                  "serverName": config_data["sni"] if config_data["sni"] else "www.google.com",
                                  "fingerprint": config_data["fp"] if config_data["fp"] else "chrome",
                                  "alpn": config_data["alpn"].split(',') if config_data["alpn"] else ["h2", "http/1.1"]
                              }
                          }
                      }
                  ]
              }

              try:
                  with open(config_path, 'w') as f:
                      json.dump(config_json, f, indent=2)
                  return True
              except IOError as e:
                  safe_print(f"âŒ Error writing Xray config file {config_path}: {e}")
                  return False

          def test_xray_config(config_data: Dict[str, Union[str, int, str]]) -> Optional[Dict[str, Union[str, int, str, float]]]:
              """
              Tests a single Xray configuration by running Xray core and attempting a curl request through it.
              Returns the config data with latency if successful, None otherwise.
              """
              temp_config_file = f"xray_config_{os.getpid()}_{threading.get_ident()}.json"

              if not create_xray_config_file(config_data, temp_config_file):
                  return None

              xray_process = None
              try:
                  # Start Xray core in the background
                  xray_process = subprocess.Popen(
                      ['xray', '-c', temp_config_file],
                      stdout=subprocess.PIPE,
                      stderr=subprocess.PIPE,
                      text=True
                  )

                  # Wait for Xray to start (check for specific log messages or just wait)
                  time.sleep(1) # Give it a moment to bind ports

                  # Verify Xray process is running and not immediately crashed
                  if xray_process.poll() is not None:
                      stderr_output = xray_process.stderr.read()
                      return None

                  # Try to connect via HTTP proxy
                  start_time = time.time()
                  curl_command = [
                      'curl',
                      '-s',           # Silent mode
                      '-o', '/dev/null', # Discard output
                      '-w', '%{time_total}', # Output total time
                      '--proxy', f'http://127.0.0.1:{XRAY_LOCAL_HTTP_PORT}',
                      '--max-time', str(TEST_URL_TIMEOUT),
                      '--retry', '1',  # Try once more if it fails
                      '--retry-connrefused', # Retry if connection refused
                      TEST_URL
                  ]

                  curl_result = subprocess.run(
                      curl_command,
                      capture_output=True,
                      text=True,
                      timeout=TEST_URL_TIMEOUT + 5 # Give curl a bit more time than its own timeout
                  )

                  latency = None
                  if curl_result.returncode == 0:
                      try:
                          latency = float(curl_result.stdout.strip()) * 1000 # Convert to milliseconds
                          if latency > 0: # Ensure it's a valid positive latency
                              config_data['real_latency_ms'] = latency
                              return config_data
                      except ValueError:
                          pass

              except subprocess.TimeoutExpired:
                  if xray_process:
                      xray_process.kill()
                      xray_process.wait()
                  return None
              except Exception as e:
                  return None
              finally:
                  if xray_process:
                      xray_process.kill()
                      xray_process.wait()
                  if os.path.exists(temp_config_file):
                      os.remove(temp_config_file)
              return None

          def main():
              if not os.path.exists(INPUT_CONFIGS_FILE):
                  safe_print(f"âŒ Input file not found: {INPUT_CONFIGS_FILE}")
                  sys.exit(1)

              safe_print("ğŸš€ Starting real VLESS Reality config testing...")

              try:
                  with open(INPUT_CONFIGS_FILE, 'r', encoding='utf-8') as f:
                      base64_content = f.read().strip()

                  decoded_content = base64.b64decode(base64_content).decode('utf-8')
                  config_urls = decoded_content.split('\n')
                  safe_print(f"Loaded {len(config_urls)} configs from {INPUT_CONFIGS_FILE}.")
              except Exception as e:
                  safe_print(f"âŒ Error loading or decoding input file: {e}")
                  sys.exit(1)

              parsed_configs: List[Dict[str, Union[str, int, str]]] = []
              for url in config_urls:
                  parsed = parse_vless_config(url)
                  if parsed:
                      parsed_configs.append(parsed)

              safe_print(f"Parsed {len(parsed_configs)} VLESS Reality configs.")

              # ÙÙ‚Ø· ØªØ¹Ø¯Ø§Ø¯ Ù…Ø­Ø¯ÙˆØ¯ÛŒ Ø§Ø² Ø¨Ù‡ØªØ±ÛŒÙ† Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ØªØ³Øª ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
              configs_to_test = parsed_configs[:MAX_CONFIGS_FOR_REAL_TEST]

              working_configs: List[Dict[str, Union[str, int, str, float]]] = []

              total_tests = len(configs_to_test)
              tested_count = 0

              max_concurrent_workers = min(os.cpu_count() or 4, 8) # Ù…Ø­Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† ØªØ±Ø¯Ù‡Ø§ Ø¨Ø±Ø§ÛŒ Ù¾Ø§ÛŒØ¯Ø§Ø±ÛŒ Ø¨ÛŒØ´ØªØ± Xray
              safe_print(f"Using {max_concurrent_workers} concurrent workers for real testing.")

              with concurrent.futures.ThreadPoolExecutor(max_workers=max_concurrent_workers) as executor:
                  futures = {executor.submit(test_xray_config, cfg): cfg for cfg in configs_to_test}

                  for i, future in enumerate(concurrent.futures.as_completed(futures)):
                      result_config = future.result()
                      if result_config:
                          working_configs.append(result_config)

                      tested_count += 1
                      print_progress(tested_count, total_tests, prefix='Real Test Progress:', suffix='Complete')

              safe_print(f"\nâœ… Found {len(working_configs)} truly working configs.")

              if working_configs:
                  # Sort by real latency
                  working_configs.sort(key=lambda x: x['real_latency_ms'])

                  final_output_list: List[str] = []
                  for i, cfg in enumerate(working_configs, start=1):
                      # Ø§ÛŒÙ†Ø¬Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ù†Ø§Ù…Ú¯Ø°Ø§Ø±ÛŒ Ú©Ø§Ù†ÙÛŒÚ¯ Ø±Ø§ Ø¨Ù‡Ø¨ÙˆØ¯ Ø¯Ù‡ÛŒØ¯
                      config_str = f"{cfg['original_config']}#Live_{i}_Latency_{cfg['real_latency_ms']:.0f}ms"
                      final_output_list.append(config_str)

                  subscription_text = "\n".join(final_output_list)
                  base64_output = base64.b64encode(subscription_text.encode('utf-8')).decode('utf-8').replace('=', '')

                  os.makedirs(os.path.dirname(OUTPUT_WORKING_CONFIGS_FILE), exist_ok=True)
                  with open(OUTPUT_WORKING_CONFIGS_FILE, 'w', encoding='utf-8') as f:
                      f.write(base64_output)

                  safe_print(f"\nğŸ‰ {len(working_configs)} truly working configs saved to {OUTPUT_WORKING_CONFIGS_FILE}")

                  safe_print(f"ğŸ† Top 5 truly working configs (for log display):")
                  for i, cfg in enumerate(working_configs[:5], start=1):
                      safe_print(
                          f"  {i}. {cfg['server']}:{cfg['port']} - "
                          f"Real Latency: {cfg['real_latency_ms']:.2f}ms"
                      )
              else:
                  safe_print("\nğŸ˜¥ No truly working configs found.")

          if __name__ == "__main__":
              main()
          EOF

      - name: Run Xray Tester Script
        run: python xray_tester.py

      - name: Commit and Push working configs
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          file_pattern: data/khanevadeh_pardazesh_shodeh_base64.txt # Ø§ÛŒÙ†Ø¬Ø§ Ù‡Ù… Ø§Ø³Ù… ÙØ§ÛŒÙ„ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ø§Ø¯ÛŒÙ…
          commit_message: "Auto-update: Xray real test results"
          # Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ú©Ù‡ Ø¯Ø³ØªØ±Ø³ÛŒ Write Ø¯Ø± Settings -> Actions -> General -> Workflow permissions ÙØ¹Ø§Ù„ Ø¨Ø§Ø´Ø¯.
