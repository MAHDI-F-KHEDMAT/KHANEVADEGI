name: Test Xray Configs

on:
  workflow_run:
    workflows: ["Automated Data Processing"]
    types:
      - completed
  workflow_dispatch: # Allows manual triggering

jobs:
  test_configs:
    runs-on: ubuntu-latest
    needs: [] # Remove dependency if you want to run independently, otherwise keep it as 'needs: [process_data_job]' if that job name is used in process_data.yml

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Download Xray
        run: |
          XRAY_VERSION="1.8.10" # You can change this to the latest stable version if needed
          XRAY_URL="https://github.com/XTLS/Xray-core/releases/download/v${XRAY_VERSION}/Xray-linux-64.zip"
          curl -L ${XRAY_URL} -o xray.zip
          unzip xray.zip -d xray
          chmod +x xray/xray
          echo "XRAY_PATH=$(pwd)/xray/xray" >> $GITHUB_ENV

      - name: Run VLESS Reality config testing
        env:
          XRAY_PATH: ${{ env.XRAY_PATH }}
        run: |
          # Create xray_tester.py directly here
          cat << 'EOF' > xray_tester.py
import base64
import os
import re
import subprocess
import json
import time

def add_base64_padding(data):
    """Adds padding to a base64 string if necessary."""
    missing_padding = len(data) % 4
    if missing_padding:
        data += '='* (4 - missing_padding)
    return data

def parse_vless_url(url):
    """Parses a VLESS Reality URL into a dictionary of components."""
    try:
        # Decode the URL (if it's base64 encoded, though VLESS URLs usually aren't directly base64)
        # Assuming the input is a direct VLESS URL, not base64 encoded itself.
        # However, if it comes from a base64 subscription, it might need decoding first.
        # For a standard VLESS URL, this initial decode is usually not needed.
        # Let's assume the input 'url' is already the decoded VLESS string.

        match = re.match(r"vless://([a-f0-9-]+)@([^:]+):(\d+)\?(.*?)#(.*)", url)
        if not match:
            # Try to decode from base64 if direct match fails, common for subscriptions
            try:
                decoded_url = base64.b64decode(add_base64_padding(url)).decode('utf-8')
                match = re.match(r"vless://([a-f0-9-]+)@([^:]+):(\d+)\?(.*?)#(.*)", decoded_url)
                if not match:
                    # If it's still not matching after decoding, it might be a malformed URL
                    return None
            except Exception as e:
                # print(f"Could not decode base64 or parse after decode: {e}")
                return None # Not a valid VLESS URL format

        uuid, address, port, params_str, name = match.groups()
        
        params = {}
        for param in params_str.split('&'):
            if '=' in param:
                key, value = param.split('=', 1)
                params[key] = value
        
        # Decode URL-encoded components if necessary (e.g., in sni, pbk, etc.)
        for key, value in params.items():
            try:
                params[key] = requests.utils.unquote(value)
            except Exception:
                pass # Keep original if unquoting fails

        # Handle 'host' parameter, which might be duplicated or used for SNI if 'sni' is missing
        sni = params.get('sni')
        if not sni:
            # If SNI is not explicitly set, sometimes 'host' or the address itself is used.
            # For Reality, 'sni' is crucial. If missing, it's likely invalid.
            pass # Keep it as None, it will be checked later.

        # Specific handling for pk/pbk based on common Reality formats
        public_key = params.get('pbk') or params.get('pk')
        if not public_key:
            return None # Reality configs must have a public key

        flow = params.get('flow', 'xtls-rprx-vision') # Default flow for Reality

        config = {
            "uuid": uuid,
            "address": address,
            "port": int(port),
            "flow": flow,
            "security": "reality",
            "sni": sni,
            "publicKey": public_key,
            "shortId": params.get('sid'),
            "fingerprint": params.get('fp', 'chrome'), # Default to chrome if not specified
            "type": params.get('type', 'tcp'), # Default to tcp if not specified
            "splice": params.get('splice') # Optional, for gRPC
        }
        return config
    except Exception as e:
        # print(f"Error parsing VLESS URL '{url}': {e}")
        return None

def create_xray_config(parsed_vless):
    """Creates an Xray JSON configuration for a VLESS Reality inbound."""
    if not parsed_vless:
        return None

    sni = parsed_vless.get('sni')
    if not sni:
        # print("Warning: SNI is missing for a Reality config. This might cause issues.")
        # For Reality, SNI is almost always required.
        return None

    # Basic Xray config structure
    xray_config = {
        "log": {
            "loglevel": "warning"
        },
        "inbounds": [
            {
                "port": 10808, # Arbitrary local port for testing
                "listen": "127.0.0.1",
                "protocol": "socks",
                "settings": {
                    "auth": "noauth",
                    "udp": True,
                    "ip": "127.0.0.1"
                }
            }
        ],
        "outbounds": [
            {
                "protocol": "vless",
                "settings": {
                    "vnext": [
                        {
                            "address": parsed_vless["address"],
                            "port": parsed_vless["port"],
                            "users": [
                                {
                                    "id": parsed_vless["uuid"],
                                    "encryption": "none",
                                    "flow": parsed_vless["flow"]
                                }
                            ]
                        }
                    ]
                },
                "streamSettings": {
                    "network": parsed_vless["type"],
                    "security": "reality",
                    "realitySettings": {
                        "dest": f"{parsed_vless['address']}:{parsed_vless['port']}",
                        "xver": 0,
                        "serverNames": [sni],
                        "publicKey": parsed_vless["publicKey"],
                        "shortIds": [parsed_vless["shortId"]] if parsed_vless.get('shortId') else [],
                        "fingerprint": parsed_vless.get('fingerprint'),
                    }
                }
            }
        ]
    }

    # Add transport settings based on network type
    if parsed_vless["type"] == "tcp":
        pass # No specific settings needed for plain TCP in streamSettings
    elif parsed_vless["type"] == "grpc":
        xray_config["outbounds"][0]["streamSettings"]["grpcSettings"] = {
            "serviceName": parsed_vless.get('serviceName', ''),
            "permitWithoutStream": parsed_vless.get('splice') == 'true' # Based on 'splice' parameter for gRPC
        }
    elif parsed_vless["type"] == "http":
        # Placeholder for http transport, often used with h2 (TLS)
        # Note: Reality with HTTP transport is less common than TCP/gRPC
        pass

    return json.dumps(xray_config, indent=2)

def test_xray_config(xray_path, config_json):
    """Tests an Xray configuration by running Xray with it."""
    try:
        # Write the config to a temporary file
        with open("config.json", "w") as f:
            f.write(config_json)

        # Start Xray process
        # Redirect stderr to stdout to capture all output
        xray_process = subprocess.Popen(
            [xray_path, "run", "-c", "config.json"],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True
        )

        # Wait for a short period to allow Xray to start and potentially connect
        time.sleep(2)

        # Check if Xray is still running (i.e., didn't crash)
        if xray_process.poll() is not None:
            stdout, _ = xray_process.communicate(timeout=1)
            # print(f"Xray process exited prematurely. Output:\n{stdout}")
            return False, "Xray exited prematurely"

        # Attempt to connect to the socks proxy to check if it's alive
        # A simple connection attempt is often enough to indicate if the proxy is running
        try:
            import socket
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(5) # Set a timeout for the connection attempt
            s.connect(("127.0.0.1", 10808)) # Connect to the local socks proxy
            s.close()
            # print("SOCKS proxy responded.")
            is_working = True
        except socket.error as e:
            # print(f"Could not connect to SOCKS proxy: {e}")
            is_working = False
        finally:
            # Terminate Xray process
            xray_process.terminate()
            try:
                xray_process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                xray_process.kill()
                # print("Xray process killed after timeout.")

        return is_working, "SOCKS proxy check" if is_working else "SOCKS proxy failed to respond"

    except Exception as e:
        # print(f"Error during Xray testing: {e}")
        return False, str(e)

if __name__ == "__main__":
    xray_executable_path = os.environ.get('XRAY_PATH')
    if not xray_executable_path:
        print("Error: XRAY_PATH environment variable not set.")
        exit(1)

    print("üöÄ Starting real VLESS Reality config testing...")

    configs_file_path = "data/khanevadeh_base64.txt"
    working_configs = []

    if not os.path.exists(configs_file_path):
        print(f"‚ùå Error: Input file '{configs_file_path}' not found.")
        exit(1)

    try:
        with open(configs_file_path, 'r') as f:
            base64_content = f.read().strip()
    except Exception as e:
        print(f"‚ùå Error loading or decoding input file: {e}")
        exit(1)

    # Decode the entire base64 content
    try:
        decoded_content = base64.b64decode(add_base64_padding(base64_content)).decode('utf-8')
        vless_urls = decoded_content.split('\n')
    except Exception as e:
        print(f"‚ùå Error decoding base64 content from file: {e}. Raw content length: {len(base64_content)}")
        print(f"Please check if '{configs_file_path}' contains valid and complete Base64 encoded data.")
        exit(1)

    if not vless_urls:
        print("‚ö†Ô∏è No VLESS URLs found in the decoded content.")
        exit(0)

    print(f"‚úÖ Found {len(vless_urls)} VLESS URLs to test.")

    for i, url in enumerate(vless_urls):
        url = url.strip()
        if not url:
            continue

        print(f"Testing config {i+1}/{len(vless_urls)}: {url[:80]}...") # Show first 80 chars
        parsed_config = parse_vless_url(url)
        
        if not parsed_config:
            print(f"  ‚ùå Failed to parse URL: {url[:100]}...")
            continue

        xray_json = create_xray_config(parsed_config)
        if not xray_json:
            print(f"  ‚ùå Failed to create Xray config for: {url[:100]}...")
            continue
        
        is_working, reason = test_xray_config(xray_executable_path, xray_json)
        
        if is_working:
            print(f"  ‚úÖ Config {i+1} is WORKING. ({reason})")
            working_configs.append(url)
        else:
            print(f"  ‚ùå Config {i+1} is NOT WORKING. ({reason})")
            
    if working_configs:
        print(f"\nüéâ Successfully identified {len(working_configs)} working configurations!")
        with open("data/working_vless_reality_configs.txt", "w") as f:
            for config in working_configs:
                f.write(config + '\n')
        print("Saved working configs to data/working_vless_reality_configs.txt")
    else:
        print("\nüòî No working VLESS Reality configurations found.")
        
    print("‚úÖ Testing complete.")
EOF
          python xray_tester.py
