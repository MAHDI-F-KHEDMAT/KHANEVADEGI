name: Secure Tunnel Checker # ูุงู ุฌุฏุฏ ูุฑฺฉููู ุฏูู

on:
  workflow_run:
    workflows: ["Automated Data Processing"] # <--- ุงู ุฎุท ุงุตูุงุญ ุดุฏ!
    types:
      - completed
    branches:
      - main # ุง ุดุงุฎู ุงุตู ุฑูพุงุฒุชูุฑ ุดูุง (ูุนูููุง main ุง master)

  workflow_dispatch: # ุจุฑุง ุงูฺฉู ุจุชูุงูุฏ ุจู ุตูุฑุช ุฏุณุช ูู ุงุฌุฑุง ฺฉูุฏ (ุงุฎุชุงุฑ)

jobs:
  test_configs_job:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Xray Core
        run: |
          # Fetch the latest Xray release tag
          XRAY_VERSION=$(curl -s "https://api.github.com/repos/XTLS/Xray-core/releases/latest" | grep -Po '"tag_name": "v\K[^"]*')
          echo "Latest Xray version: v${XRAY_VERSION}"

          # Download Xray Core for Linux 64-bit
          XRAY_URL="https://github.com/XTLS/Xray-core/releases/download/v${XRAY_VERSION}/Xray-linux-64.zip"
          echo "Downloading Xray from: ${XRAY_URL}"
          curl -L -o xray.zip $XRAY_URL

          # Unzip Xray core and essential data files (Xray.dat removed from unzip command)
          unzip xray.zip xray geoip.dat geosite.dat
          
          # Move xray binary to a PATH directory and make it executable
          sudo mv xray /usr/local/bin/
          sudo chmod +x /usr/local/bin/xray
          
          # Create Xray data directory and move data files (Xray.dat removed from mv command)
          sudo mkdir -p /usr/local/share/xray/
          sudo mv geoip.dat geosite.dat /usr/local/share/xray/
          
          echo "Xray installed successfully. Version:"
          xray version
        
      - name: Create Xray Tester Script (xray_tester.py)
        run: |
          cat << 'EOF' > xray_tester.py
          # -- coding: utf-8 --
          import base64
          import json
          import os
          import re
          import subprocess
          import sys
          import time
          import threading
          from typing import List, Dict, Union, Optional
          import concurrent.futures

          # --- Global Constants & Variables ---
          
          PRINT_LOCK = threading.Lock() 

          # ูุณุฑ ูุงู ูุฑูุฏ (ุชููุฏ ุดุฏู ุชูุณุท Workflow ูุจู)
          INPUT_CONFIGS_FILE = "data/khanevadeh_base64.txt" # ูุงู ุฎุฑูุฌ ูุฑฺฉููู ุงูู
          # ูุณุฑ ูุงู ุฎุฑูุฌ ุจุฑุง ฺฉุงููฺฏโูุง ูุนุงู ูุงูุน
          OUTPUT_WORKING_CONFIGS_FILE = "data/secure_access_list.txt" # ุงุณู ูุงู ุฎุฑูุฌ ุฌุฏุฏ ูุฑฺฉููู ุฏูู

          # ุญุฏุงฺฉุซุฑ ุชุนุฏุงุฏ ฺฉุงููฺฏโูุง ฺฉู ูโุฎูุงูู ุชุณุช ูุงูุน ฺฉูู (ุจุฑุง ูุฏุฑุช ุฒูุงู GitHub Actions)
          MAX_CONFIGS_FOR_REAL_TEST = 100 
          
          # ูพูุฑุช ุฏุงุฎู ฺฉู Xray ุฑู ุขู ูพุฑูฺฉุณ SOCKS5 ุงุฌุงุฏ ูโฺฉูุฏ
          XRAY_LOCAL_SOCKS_PORT = 1080
          # ูพูุฑุช ุฏุงุฎู ฺฉู Xray ุฑู ุขู ูพุฑูฺฉุณ HTTP ุงุฌุงุฏ ูโฺฉูุฏ (ุจุฑุง curl)
          XRAY_LOCAL_HTTP_PORT = 1081

          # ุฒูุงูโุจูุฏโูุง
          XRAY_STARTUP_TIMEOUT = 10 # ุซุงูู ุจุฑุง ุดุฑูุน Xray
          TEST_URL_TIMEOUT = 10     # ุซุงูู ุจุฑุง curl ฺฉุฑุฏู URL ุชุณุช
          
          # URL ุจุฑุง ุชุณุช ุงุชุตุงู ูุงูุน (ุชูุตู ูโุดูุฏ ฺฉ URL ูุนุชุจุฑ ู ุนููู ุจุงุดุฏ ฺฉู ุฏุฑ ุงุฑุงู ููุชุฑ ูุณุช ู ุงุฒ CDN ุงุณุชูุงุฏู ููโฺฉูุฏ)
          TEST_URL = "https://www.google.com/generate_204"

          VLESS_PARSE_PATTERN: re.Pattern = re.compile(
              r"vless://"
              r"(?P<uuid>[a-f0-9-]+)"     
              r"@"
              r"(?P<server>[^:]+)"       
              r":"
              r"(?P<port>\d+)"           
              r"\?"                      
              r"(?:[^&]*&)*"             
              r"security=reality"        
              r"(?:[^&]*&)*"             
              r"pbk=(?P<pbk>[^&]+)"      
              r"(?:[^&]*&)*"             
              r"(?:fp=(?P<fp>[^&]+))?"   
              r"(?:&sni=(?P<sni>[^&]+))?"
              r"(?:&alpn=(?P<alpn>[^&]+))?"
              r".*$",                    
              re.IGNORECASE
          )
          
          def safe_print(message: str) -> None:
              with PRINT_LOCK:
                  print(message)

          def print_progress(iteration: int, total: int, prefix: str = '', suffix: str = '', bar_length: int = 50) -> None:
              with PRINT_LOCK:
                  percent = ("{0:.1f}").format(100 * (iteration / float(total)))
                  filled_length = int(bar_length * iteration // total)
                  bar = 'โ' * filled_length + '-' * (bar_length - filled_length)
                  sys.stdout.write(f'\r{prefix} |{bar}| {percent}% {suffix}')
                  sys.stdout.flush()
                  if iteration == total:
                      sys.stdout.write('\n')

          def parse_vless_config(config_str: str) -> Optional[Dict[str, Union[str, int, str]]]:
              match = VLESS_PARSE_PATTERN.match(config_str)
              if match:
                  parts = match.groupdict()
                  if all(parts.get(k) for k in ["uuid", "server", "port", "pbk"]):
                      try:
                          port_int = int(parts["port"])
                          return {
                              "uuid": parts["uuid"],
                              "server": parts["server"],
                              "port": port_int,
                              "pbk": parts["pbk"],
                              "fp": parts.get("fp", ""),
                              "sni": parts.get("sni", ""),
                              "alpn": parts.get("alpn", "h2,http/1.1"), 
                              "original_config": config_str
                          }
                      except ValueError:
                          return None
              return None

          def create_xray_config_file(config_data: Dict[str, Union[str, int, str]], config_path: str) -> bool:
              """Creates a temporary Xray config file for a given VLESS Reality configuration."""
              config_json = {
                  "log": {
                      "loglevel": "warning"
                  },
                  "inbounds": [
                      {
                          "port": XRAY_LOCAL_SOCKS_PORT,
                          "protocol": "socks",
                          "settings": {
                              "auth": "noauth",
                              "udp": True,
                              "ip": "127.0.0.1"
                          }
                      },
                      {
                          "port": XRAY_LOCAL_HTTP_PORT,
                          "protocol": "http",
                          "settings": {
                              "ip": "127.0.0.1"
                          }
                      }
                  ],
                  "outbounds": [
                      {
                          "protocol": "vless",
                          "settings": {
                              "vnext": [
                                  {
                                      "address": config_data["server"],
                                      "port": config_data["port"],
                                      "users": [
                                          {
                                              "id": config_data["uuid"],
                                              "encryption": "none"
                                          }
                                      ]
                                  }
                              ]
                          },
                          "streamSettings": {
                              "network": "tcp",
                              "security": "reality",
                              "realitySettings": {
                                  "publicKey": config_data["pbk"],
                                  "shortId": "", 
                                  "fingerprint": config_data["fp"] if config_data["fp"] else "chrome", 
                                  "serverNames": [config_data["sni"]] if config_data["sni"] else ["www.google.com"], 
                                  "spiderX": ""
                              },
                              "tlsSettings": {
                                  "serverName": config_data["sni"] if config_data["sni"] else "www.google.com",
                                  "fingerprint": config_data["fp"] if config_data["fp"] else "chrome",
                                  "alpn": config_data["alpn"].split(',') if config_data["alpn"] else ["h2", "http/1.1"]
                              }
                          }
                      }
                  ]
              }
              
              try:
                  with open(config_path, 'w') as f:
                      json.dump(config_json, f, indent=2)
                  return True
              except IOError as e:
                  safe_print(f"โ Error writing Xray config file {config_path}: {e}")
                  return False

          def test_xray_config(config_data: Dict[str, Union[str, int, str]]) -> Optional[Dict[str, Union[str, int, str, float]]]:
              """
              Tests a single Xray configuration by running Xray core and attempting a curl request through it.
              Returns the config data with latency if successful, None otherwise.
              """
              temp_config_file = f"xray_config_{os.getpid()}_{threading.get_ident()}.json"
              
              if not create_xray_config_file(config_data, temp_config_file):
                  return None
              
              xray_process = None
              try:
                  # Start Xray core in the background
                  xray_process = subprocess.Popen(
                      ['xray', '-c', temp_config_file],
                      stdout=subprocess.PIPE,
                      stderr=subprocess.PIPE,
                      text=True
                  )
                  
                  # Wait for Xray to start (check for specific log messages or just wait)
                  time.sleep(1) # Give it a moment to bind ports

                  # Verify Xray process is running and not immediately crashed
                  if xray_process.poll() is not None:
                      stderr_output = xray_process.stderr.read()
                      return None
                  
                  # Try to connect via HTTP proxy
                  start_time = time.time()
                  curl_command = [
                      'curl',
                      '-s',           # Silent mode
                      '-o', '/dev/null', # Discard output
                      '-w', '%{time_total}', # Output total time
                      '--proxy', f'http://127.0.0.1:{XRAY_LOCAL_HTTP_PORT}',
                      '--max-time', str(TEST_URL_TIMEOUT),
                      '--retry', '1',  # Try once more if it fails
                      '--retry-connrefused', # Retry if connection refused
                      TEST_URL
                  ]
                  
                  curl_result = subprocess.run(
                      curl_command,
                      capture_output=True,
                      text=True,
                      timeout=TEST_URL_TIMEOUT + 5 
                  )
                  
                  latency = None
                  if curl_result.returncode == 0:
                      try:
                          latency = float(curl_result.stdout.strip()) * 1000 # Convert to milliseconds
                          if latency > 0: 
                              config_data['real_latency_ms'] = latency
                              return config_data
                      except ValueError:
                          pass

              except subprocess.TimeoutExpired:
                  if xray_process:
                      xray_process.kill()
                      xray_process.wait()
                  return None
              except Exception as e:
                  return None
              finally:
                  if xray_process:
                      xray_process.kill()
                      xray_process.wait()
                  if os.path.exists(temp_config_file):
                      os.remove(temp_config_file)
              return None

          def main():
              if not os.path.exists(INPUT_CONFIGS_FILE):
                  safe_print(f"โ Input file not found: {INPUT_CONFIGS_FILE}")
                  sys.exit(1)

              safe_print("๐ Starting real VLESS Reality config testing...")
              
              try:
                  with open(INPUT_CONFIGS_FILE, 'r', encoding='utf-8') as f:
                      base64_content = f.read().strip()
                  
                  decoded_content = base64.b64decode(base64_content).decode('utf-8')
                  config_urls = decoded_content.split('\n')
                  safe_print(f"Loaded {len(config_urls)} configs from {INPUT_CONFIGS_FILE}.")
              except Exception as e:
                  safe_print(f"โ Error loading or decoding input file: {e}")
                  sys.exit(1)

              parsed_configs: List[Dict[str, Union[str, int, str]]] = []
              for url in config_urls:
                  parsed = parse_vless_config(url)
                  if parsed:
                      parsed_configs.append(parsed)
              
              safe_print(f"Parsed {len(parsed_configs)} VLESS Reality configs.")
              
              # ููุท ุชุนุฏุงุฏ ูุญุฏูุฏ ุงุฒ ุจูุชุฑู ฺฉุงููฺฏโูุง ุฑุง ุจุฑุง ุชุณุช ูุงูุน ุงูุชุฎุงุจ ูโฺฉูู
              configs_to_test = parsed_configs[:MAX_CONFIGS_FOR_REAL_TEST]
              
              working_configs: List[Dict[str, Union[str, int, str, float]]] = []
              
              total_tests = len(configs_to_test)
              tested_count = 0
              
              max_concurrent_workers = min(os.cpu_count() or 4, 8) # ูุญุฏูุฏ ฺฉุฑุฏู ุชุฑุฏูุง ุจุฑุง ูพุงุฏุงุฑ ุจุดุชุฑ Xray
              safe_print(f"Using {max_concurrent_workers} concurrent workers for real testing.")

              with concurrent.futures.ThreadPoolExecutor(max_workers=max_concurrent_workers) as executor:
                  futures = {executor.submit(test_xray_config, cfg): cfg for cfg in configs_to_test}
                  
                  for i, future in enumerate(concurrent.futures.as_completed(futures)):
                      result_config = future.result()
                      if result_config:
                          working_configs.append(result_config)
                      
                      tested_count += 1
                      print_progress(tested_count, total_tests, prefix='Real Test Progress:', suffix='Complete')
              
              safe_print(f"\nโ Found {len(working_configs)} truly working configs.")
              
              if working_configs:
                  # Sort by real latency
                  working_configs.sort(key=lambda x: x['real_latency_ms'])

                  final_output_list: List[str] = []
                  for i, cfg in enumerate(working_configs, start=1):
                      # ุงูุฌุง ูโุชูุงูุฏ ูุงูฺฏุฐุงุฑ ฺฉุงููฺฏ ุฑุง ุจูุจูุฏ ุฏูุฏ
                      config_str = f"{cfg['original_config']}#Live_{i}_Latency_{cfg['real_latency_ms']:.0f}ms"
                      final_output_list.append(config_str)

                  subscription_text = "\n".join(final_output_list)
                  base64_output = base64.b64encode(subscription_text.encode('utf-8')).decode('utf-8').replace('=', '')

                  os.makedirs(os.path.dirname(OUTPUT_WORKING_CONFIGS_FILE), exist_ok=True)
                  with open(OUTPUT_WORKING_CONFIGS_FILE, 'w', encoding='utf-8') as f:
                      f.write(base64_output)
                  
                  safe_print(f"\n๐ {len(working_configs)} truly working configs saved to {OUTPUT_WORKING_CONFIGS_FILE}")
                  
                  safe_print(f"๐ Top 5 truly working configs (for log display):")
                  for i, cfg in enumerate(working_configs[:5], start=1):
                      safe_print(
                          f"  {i}. {cfg['server']}:{cfg['port']} - "
                          f"Real Latency: {cfg['real_latency_ms']:.2f}ms"
                      )
              else:
                  safe_print("\n๐ฅ No truly working configs found.")

          if __name__ == "__main__":
              main()
          EOF
        
      - name: Run Xray Tester Script
        run: python xray_tester.py
        
      - name: Commit and Push working configs
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          file_pattern: data/secure_access_list.txt # ูุงู ูุงู ุฎุฑูุฌ ุฌุฏุฏ ุจุฑุง Commit
          commit_message: "Auto-update: Xray real test results"
          # ูุทูุฆู ุดูุฏ ฺฉู ุฏุณุชุฑุณ Write ุฏุฑ Settings -> Actions -> General -> Workflow permissions ูุนุงู ุจุงุดุฏ.
